# -*- coding: utf-8 -*-
"""KPCA better.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wPkQ8TtS06dOc991HHs2QBsMv_fCMQs2
"""

import numpy as np

def kernel_pca(X, kernel, gamma):
    #"""
    #Perform Kernel PCA on the input data using the specified kernel.
    
    #Parameters
    #----------
    #X : array-like, shape (n_samples, n_features)
    #    The input data.
    #kernel : string
    #    The type of kernel to use. Must be one of 'linear', 'poly', or 'rbf'.
    #gamma : float
    #    The kernel coefficient for the RBF kernel. Ignored for the other kernels.
    
    #Returns
    #-------
    #X_transformed : array-like, shape (n_samples, n_components)
    #    The transformed data.
    #"""
    
    # Normalize the data
    X = (X - np.mean(X, axis=0)) / np.std(X, axis=0)
    
    # Compute the kernel matrix
    n_samples = X.shape[0]
    K = np.zeros((n_samples, n_samples))
    for i in range(n_samples):
        for j in range(n_samples):
            if kernel == 'linear':
                K[i, j] = np.dot(X[i], X[j])
            elif kernel == 'poly':
                K[i, j] = (np.dot(X[i], X[j]) + 1) ** gamma
            elif kernel == 'rbf':
                K[i, j] = np.exp(-gamma * np.linalg.norm(X[i] - X[j]) ** 2)
    
    # Compute the eigenvectors and eigenvalues of the kernel matrix
    eigenvalues, eigenvectors = np.linalg.eig(K)
    
    # Sort the eigenvectors in decreasing order of their corresponding eigenvalues
    eigenvalues_sorted_indices = np.argsort(eigenvalues)[::-1]
    eigenvectors = eigenvectors[:, eigenvalues_sorted_indices]
    
    # Select the number of dimensions to retain
    k = 2  # Change this value to specify the number of dimensions to retain
    eigenvectors = eigenvectors[:, :k]
    
    # Transform the data into the new space
    X_transformed = np.dot(K, eigenvectors)
    
    return X_transformed